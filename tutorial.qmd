---
engine: julia
execute:
  warning: false
  output: false
---

## Introduction

The purpose of this tutorial is to demonstrate that by modelling the random error $\sigma$ we can estimate species-area relationships across the full spectrum of areas, i.e., without relying on introducing breakpoints.

The `R` and `julia` code provided here covers for the following steps:

1. Simulation of species richness for islands nested in archipelagos
2. Visual inspection of the simulated data
3. Modeling the species-area relationship
4. Validation of the results

## Set up

We begin by loading the required packages in both programming languages.

```{julia}
using RCall
using Distributions
using LinearAlgebra
using Turing
using StatsPlots
# using Logging maybe needed to suppress Turing's progress meter
```

```{r}
library(brms)
library(tidyverse)
library(truncdist)
```

## Simulating data

We begin by setting the fixed parameters for the simulation.
In the notation below $c$ represents an archipelago intercept and $z$ the coefficient for island area $A$ onto species richness $S$.

This gives us Arrhenius law:

$$
S = c A^z
$$

Underlying the $c$ are the hyperparameters $\bar{c}$, the mean of all archipelago intercepts, and $\tau$ the variation of atoll intercepts.

The parameters which together will determine the random error $\sigma$ are the baseline error $\sigma_{base}$, $\gamma_{area}$ and $\gamma_{precip}$.

```{julia}
n_archipelago = 16
c̄ = 0.0
τ = 0.5
c = rand(Normal(c̄, τ), n_archipelago)
z = 3.0
γ_area = -1.5
γ_precip = -0.8
σ_base = 0.0
```

```{r}
n_archipelago <- 16
c_bar <- 1
tau <- 0.5
c <- rnorm(n_archipelago, mean = c_bar, sd = tau)
z <- 3
gamma_area <- -1.5
gamma_precip <- -0.8
sigma_base <- 0.0
```

We then draw the number of islands for each archipelago from a Poisson distribution with $\lambda = 20$ and truncated at a lower bound of $4$. <!-- truncation is probably redundant given the distribution of Poisson(20) -->

```{julia}
trunc_pois = truncated(Poisson(20), lower=4)
islands_per_archipelago = rand(trunc_pois, n_archipelago)
n_islands = sum(islands_per_archipelago)

archipelago = reduce(vcat, fill.(1:n_archipelago, islands_per_archipelago))
```

```{r}
#| output: true
dat <- tibble(
  archipelago = 1:n_archipelago,
  n_islands = truncdist::rtrunc(n_archipelago, "pois", a = 4, b = Inf, lambda = 20),
  precip = rnorm(n_archipelago, mean = 0, sd = 1)
) %>%
  tidyr::uncount(n_islands) %>%
  mutate(
    area = rnorm(nrow(.), mean = 0, sd = 1),
    island = seq_len(nrow(.))
  )
```

Finally, we simulate the species `richness` for each island by taking into account each archipelago's intercept and precipitation values.

```{julia}
#| output: true
area = rand(Normal(0, 1), n_islands)
precip = rand(Normal(0, 1), n_archipelago)

richness = let j = archipelago
	μ = @. c[j] + area * z
	σ = @. exp(σ_base + γ_area * area + γ_precip * precip[j])
	rand(MvNormal(μ, σ))
end
```

```{r}
mu <- c[dat$archipelago] + dat$area * z
sigma <- exp(sigma_base + gamma_area * dat$area + gamma_precip * dat$precip)
dat$richness <- rnorm(nrow(dat), mean = mu, sd = sigma)
dat
```

## Model

In `julia`, we use the probabilistic programming language Turing.jl to specify the model.
The more lengthy but also more explicit model syntax reveals that the likelihood in our model directly matches the data-generating process.

```{julia}
@model function distributional_model(archipelago, area, precip)
	j = length(unique(archipelago))

	# Priors
	α_bar_area ~ Normal(0, 1)
	τ_area ~ Exponential(1)
	α_area ~ filldist(Normal(α_bar_area, τ_area), j)

	β_area ~ Normal(0, 1)

	σ_base ~ Cauchy(0, 1)
	γ_area ~ Normal(0, 0.25)
	γ_precip ~ Normal(0, 0.25)

	# Likelihood
	μ = @. α_area[archipelago] + β_area * area
	σ = @. exp(σ_base + γ_area * area + γ_precip * precip[archipelago])
	richness ~ MvNormal(μ, σ.^2)

	return (; μ, σ)
end
```

In `R`, we can use the `brms` package to specify the equivalent model with `R`'s widely-used formula syntax.

Note that the `save_pars = save_pars(all = TRUE)` is only necessary if model evaluation techniques such as leave-one-out crossvalidation `loo()` are to be used.

```{julia}
#| output: true
prior_model = distributional_model(archipelago, area, precip)
conditioned_model = prior_model | (richness=richness,)
chn = sample(conditioned_model, NUTS(), 1000)
```

```{r}
#| output: true
formula <- bf(
  richness ~ area + (1 | archipelago),
  sigma ~ area + precip
)

model <- brm(
	formula, 
	data = dat,
	family = gaussian(),
	prior = NULL,
    warmup = 1000,
	iter = 2000,
	chains = 4,
	save_pars = save_pars(all = TRUE)
  )

summary(model)
```

## Validation

Model validation steps for MCMC sampling.

```{julia}
#| output: false
plot(chn)
```
